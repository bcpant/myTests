#------------------------------------------------------------------------------------------
#                                   Что такое замыкание?
#------------------------------------------------------------------------------------------ 
# Замыкание - это механизм, когда одна функция использует переменные из внешней области видимости.

def add_number(a):
    def add(b):
        return a + b
    return add

add_five = add_number(5)
print(add_five(3)) # выведет 8

#------------------------------------------------------------------------------------------
#                                Что такое декоратор и зачем он нужен?
#------------------------------------------------------------------------------------------ 
# Декоратор - это паттерн проектирования. Он нужен, чтобы изменить поведение  функции или
# класса без изменения их исходного кода
#------------------------------------------------------------------------------------------
#                                Реализация декоратора в python?
#------------------------------------------------------------------------------------------ 
# Канонически, декоратор реализуется с помощью класса, но в python есть синтаксический сахар (@decorator)
# Функция - это объект первого класса. Это значит, что функцию можно передать в одну функцию в качестве аргумента
# и можно вернуть из другой функции в качестве результата.
# Для реализации декоратора, необходимо реализовать замыкание, которое принимает функцию, внутри этого декоратора
# мы пишем функцию-обёртку, которая пробрасывает аргументы в исходную функцию. Мы можем вызвать какие-либо действия
# до выполнения нашей функции, потом вызвать эту функцию, передать в неё аргументы, выполнить действия после нашей функции
# и вернуть результат. Тем самым мы добавили дополнительное поведение до, и после.

def decorator(func):
    def wrapper(*args, **kwargs):
        print("BEFORE")
        result = func(*args, **kwargs)
        print("AFTER")
        return result
    return wrapper

# Чтобы применить декоратор к какой-то функции, достаточно написать перед ней @decorator

@decorator
def say_hi(name):
    print(f"Hi, my name is {name}")
    return 1

say_hi("Toha")

#------------------------------------------------------------------------------------------
#                      Как реализовать декоратор, который может принимать аргументы?
#------------------------------------------------------------------------------------------ 
# Чтобы это реализовать, нужно добавить дополнительный уровень вложенности.

def repeat(n):
    def decoracor(func):
        def wrapper(*args, **kwargs):
            print("BEFORE")
            result = []
            for _ in range(n):
                r = func(*args,**kwargs)
                result.append(r)
            print("AFTER")
            return result
        return wrapper
    return decoracor

@repeat(3)
def say_hi(name):
    print(f"Hi, my name is {name}")
    return 1

say_hi("Toha")
        