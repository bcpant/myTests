#                                       Что такое PEP8? 
# 
# PEP (Python Enhacement Proposal) - это предложения по развитию
# Python. Процесс PEP является основным механизмом для предложения
# новых возможностей и для документирования проектных решений,
# которые вошли в Python
#------------------------------------------------------------------------------------------

#PEP8 - это style guide того, как должен быть оформлен код,
#написанный на Python.
#------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------


# Неизменяемые типы:
str, bytes, int, float, complex, bool, None, tuple, frozenset
#------------------------------------------------------------------------------------------
# Изменяемые типы:
list, set, dict, bytearray, memoryview
#------------------------------------------------------------------------------------------


#------------------------------------------------------------------------------------------
#                   Что такое виртуальное окружение? Для чего? С помощью каких
#                           инструментов используется? (Venv)
#------------------------------------------------------------------------------------------
# Например, если нужно запустить один и тот же проект с одного компьютера, но с разных весий Python.
# Создается что-то по типу песочницы от локального Python к глобальному
# Можно локально устанавливать различные библиотеки локально, не влияя на глобальный Python!
#------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------
#           Возможно ли изменить элемент в кортеже, если кортеж - неизменяемый тип данных?
#----------------------------------------------------------------------------
# Кортеж из чисел, в том числе с плавающей точкой и комплексных
numbers_tuple = (1, 2, 3, 4, 5, 2.5, 3 + 4j)
fruits_tuple = ('яблоко', 'банан', 'апельсин')
my_tuple = (True, False)
nested_tuple = ((1, 2), ('a', 'b'))
my_tuple = ([1, 2, 3], ['a', 'b', 'c'])
my_tuple = ({'name': 'Alice', 'age': 30}, {'name': 'Bob', 'age': 25})
mixed_tuple = (1, 'hello', [1, 2, 3], {'a': 10})
#-----------------------------------------------------------------------------
# Хоть кортеж и не изменяемый тип данных, но мы может изменить изменяемые элементы его структуры,
# но саму структуру изменить нельзя.
#------------------------------------------------------------------------------------------


#------------------------------------------------------------------------------------------
#                       Что такое list, set, dict comprehensions? Примеры?
#------------------------------------------------------------------------------------------
l = [i for i in range(5) if i % 2 == 0] #list compr
s = {i for i in range(5) if i % 2 == 0} #set comp
d = {i: i ** 2 for i in range(5) if i % 2 == 0}#dict comp
# Для распаковки коллекций, генератора, для замены очень простого цикла, когда это не мешает читабельности кода
#------------------------------------------------------------------------------------------


#                        Какая разница между операторами == и is?
#------------------------------------------------------------------------------------------
a = [1,2,3]
b = [1,2,3]
(a==b)#True
(a is b) #False ссылаются на разные элементы
#------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------
#                       Что такое глубокая (deep) и поверхностная (shallow) копия?
#                       Зачем нужны? Как их сделать?
#------------------------------------------------------------------------------------------
import copy
a = [1,[2]]
b = copy.copy(a)
b.append(3)
b[1].append(4)
#Зглубокая
import copy
a = [1,[2]]
b = copy.deepcopy(a)
b.append(3)
b[1].append(4)
#------------------------------------------------------------------------------------------
# and, or, not
#------------------------------------------------------------------------------------------
# not
print(not {1,2,3})
#------------------------------------------------------------------------------------------
# and or
print([] and 123) # result: []
#                   Eсли первый оперант является True, то возвращает второй оперант
#                       если False, то False
#------------------------------------------------------------------------------------------
print([] or 123)
#------------------------------------------------------------------------------------------
#                   Как работает разрешение пространств имён в Python?
#                   Как работает правило LEGB (Local, Enclosing, Global, Built-in)
#------------------------------------------------------------------------------------------
# Разрешение имён работает по правилу LEGB
# Сначала переменная ищется в "local" -> "enclosing" -> "global" -> built in (в пространстве имён питон)
#------------------------------------------------------------------------------------------
str = "global"
def outer():
    str = "enclosing"
    def inner():
        str = "local"
#------------------------------------------------------------------------------------------
#                            Как работают операторы global и nonlocal?
#------------------------------------------------------------------------------------------
a = 1
def outer():
    b = 1
    def inner():
        #global a (result:a = 2)
        a=2
        #nonlocal b (result:b = 2)
        b=2
    inner()
    print("a =", a) # a = 1
    print("b =", b) # b = 1
outer() 
#------------------------------------------------------------------------------------------
#               Знакомы ли тебе такие функции как map, filter, zip? Приведи примеры их использования.
#------------------------------------------------------------------------------------------  
# map() - это функция, которая может быть применена к коллекции, она применяет некоторую
#функцию в нашей коллекции.
#------------------------------------------------------------------------------------------  
a = [i for i in range(5)]
b = map(lambda x: x**2, a)
print(list(b)) # [0, 1, 4, 9, 16] 
#------------------------------------------------------------------------------------------  
# filter() - так же применяет некоторую функцию к каждому элементу коллекции. Если функция,
# которая является нулевым элементом, возвращает True, то этот элемент остаётся в последовательности.
# Если False, то нет.
#------------------------------------------------------------------------------------------  
a = [i for i in range(5)]
b = filter(lambda x: x % 2 == 0, a)
print(list(b)) # [0, 2, 4]
#------------------------------------------------------------------------------------------  
# zip() - может пройтись сразу по нескольким коллекциям
#------------------------------------------------------------------------------------------  
a = [1, 2, 3]
b = [4, 5, 6, 7]
c = [8, 9]
for i in zip(a, b, c):
    print(i) #(1, 4, 8)
             #(2, 5, 9)
#------------------------------------------------------------------------------------------  
#                   Как оценивается сложность алгоритмов и почему?
#                           Что такое Big-O notation  
#------------------------------------------------------------------------------------------  
# Алгоритмическая сложность оценивыается в Big-O notation.
# Big-O notation - метод оценки, который определяет, как изменятся затраты
# на выполнение в зависимости от величины входных данных.
# Шпаргалка: www.bigocheatsheet.com
# ------------------------------------------------------------------------------------------  
# ------------------------------------------------------------------------------------------  
#                   Какая алгоритмическая сложность основных оппераций в коллекциях?
# ------------------------------------------------------------------------------------------  
# Если говорить о списках, то это будет "линейная сложность", за исключением тех операций,
# которые выполняются в конце списка.
# Если говорить про set и dict то это будет сложность за единицу, так как это hash коллекции          