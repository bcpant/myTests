#------------------------------------------------------------------------------------------
#                                          Classes
#------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------
#                                       Что такое класс?
#------------------------------------------------------------------------------------------
# Класс - модель для создания объектов определенного типа, описывающая их структуру и
# поведение.
#------------------------------------------------------------------------------------------


#------------------------------------------------------------------------------------------
#                                       Что такое объект класса?
#------------------------------------------------------------------------------------------
# Объект класса (экземпляр) - некоторая уникальная сущность определенного типа (класса),
# которая обладает структурой и поведением (описанными в самом классе)
#------------------------------------------------------------------------------------------


#------------------------------------------------------------------------------------------
#                           Как реализовать метод объекта? Что такое self?
#------------------------------------------------------------------------------------------
class Person:
    name: str

    def __init__(self, name):
        self.name = name

    def say_hi(self):
        print(f"Hi, my name is {self.name}!")

p = Person("Antony")
p.say_hi()

#------------------------------------------------------------------------------------------
#                           Как реализовать метод класса? Что такое cls?
#------------------------------------------------------------------------------------------      
class Person:
    work_place = "My company"

    @classmethod
    def get_my_work_place(cls):
        return cls.work_place
        
print(Person.get_my_work_place()) #result -> My company
# Метод класса - это метод, который пренадлежит классу целиком.
# cls - ссылка на сам класс. Из метода имеется доступ к классу и его атрибутам.


#------------------------------------------------------------------------------------------
#                           Как реализовать статический метод?
#------------------------------------------------------------------------------------------    
# Не принимают self или cls как специальный атрибут. Не имеют доступа к объекту.
class A:
    @staticmethod
    def get_current_datetime():
        from datetime import datetime
        return datetime.now()
# Можно вызывать из класса, из объекта класса.


#------------------------------------------------------------------------------------------  
#               Как в Python реализуется public, private, protected?    
#------------------------------------------------------------------------------------------  
class A:
    public = 123
    _protected = 123
    __private = 123

#------------------------------------------------------------------------------------------  
#               Как получить доступ к private атрибуту/методу из объекта?    
#------------------------------------------------------------------------------------------  

a = A()
print(a._A__private) # Нижний слеш => имя класса => 2 нижних слеша => имя приватного поля/метода

#------------------------------------------------------------------------------------------  
#               Как в классах хранятся атрибуты и методы?    
#------------------------------------------------------------------------------------------ 
# Все атрибуты и методы хранятся в словаре, посмотреть можно с помощью команды
# print(A.__dict__)
# 
# 
#------------------------------------------------------------------------------------------  
#               Чем отличается атрибут класса от атрибута объекта? 
#       Возможно ли использовать одинаковое имя для атрибута класса и атрибута объекта?  
#------------------------------------------------------------------------------------------ 
# Если мы меняем атрибут класса, то он меняется у всех объектов класса, а если у объекта,
# то только у этого объекта.
# Одинаково именовать можно, так как это просто 2 разных словаря с одинаковым названием атрибута.

#------------------------------------------------------------------------------------------  
#                               Зачем нужен декоратор @property?
#------------------------------------------------------------------------------------------ 

class Person:
    first_name: str
    last_name: str

    def __init__(self, first_name:str, last_name:str):
        self.first_name = first_name
        self.last_name = last_name

    @property # Используется как геттер
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

    @full_name.setter # Используется как сеттер (@gettername.setter)
    def full_name(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name



me = Person("Anton", "Bublikov")
print(me.full_name)        


# Можно заметить, что @property похож на атрибут, но это функция, которая выполняется в runtime 
# и динамически расчитывает это значение

#------------------------------------------------------------------------------------------  
#                           Что такое абстрактный класс?
#                   Зачем они нужны? Как они реализуются в Python?                            
#------------------------------------------------------------------------------------------ 
# В Python у нас нету интерфейсов, поэтому вместо них используют абстрактные классы.
# Объект абстрактного класса нельзя создать! В абстрактном классе мы определяем интерфейс,
# а в классах-потомках этот интерфейс обязательно должен быть реализован.
from abc import ABC
class Animal(ABC):
    pass
# Класс, описанный выше, ещё не является абстрактным, так как мы можем создать его экземпляр
# dog = Animal()
# Чтобы класс стал абстрактным, нужно описать абстрактные методы (или метод), реализация ниже.
from abc import ABC, abstractmethod
class Animal(ABC):
    @abstractmethod
    def say_somethng(self):
        raise NotImplementedError("Abstract method...")

class Cat(Animal):
    def say_somethng(self):
        print("Meow!!!!!!")

#------------------------------------------------------------------------------------------  
#                           Какая разница между методами __new__ и __init__
#                           Какой из них вызывается первым?                           
#------------------------------------------------------------------------------------------ 

# В Python нет конструктора, а есть метод, который создает объект, и метод, который
# инициализирует объект.
# Метод который создает объект = это метод __new__. Его задача создать некоторый объект
# и вернуть его из этого метода. Далее идёт метод __init__. Он отвечает за инициализацию
# объекта, то есть он получает готовый, созданный объект и заполняет его какими-то
# атрибутами.

class A:
    def __new__(cls, *args, **kwargs): # Вызывается первым, создаёт объект
        print("NEW!")
        obj = super().__new__(cls, *args, **kwargs)
        return obj
    def __init__(self): # Вызывается вторым, заполняет объект
        print("INIT!")
        self.some = 1
a = A() # result => NEW!INIT!        

#------------------------------------------------------------------------------------------  
#                           Какая разница между методами __str__ и __repr__
#                           Какой из них использовать?                          
#------------------------------------------------------------------------------------------ 
# Оба метода отвечают за строковое представление объекта. str - это метод, который отвечает за
# строковое представление ближе к пользователю, а repr для представления ближе к объекту
class Cat:
    name: str

    def __init__(self, name):
        self.name = name

    def __repr__(self) -> str:
        return f"cat(name='{self.name}')" 

    def __str__(self) -> str:
        return f"It is my cat {self.name}" 


c = Cat(name="Fira")      

# В первую очередь ищет определение str, если его нету, то repr, если repr тоже не определен,
# то получим repr от родительского класса object
# Если у нас определён str, но мы хотим узнать repr, то используем repr(something):
print(repr(c)) # вот так!

#------------------------------------------------------------------------------------------  
#                           Зачем может быть использована функция super?                   
#------------------------------------------------------------------------------------------ 
# Функция super может использоваться для того, чтобы обращаться к методу родительского класса
# Чаще всего это встречается в инициализаторах

class A:
    def __init__(self, a):
        self.a = A
class B(A):
    def __init__(self, a, b):
        super().__init__(a)
        self.b = b        

